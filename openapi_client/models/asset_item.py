# coding: utf-8

"""
    HL Connector

    HL Connector provides a simplified API interface to Hal Leonard's Digital Asset Management (DAM) system. This API enables vendors to integrate with Hal Leonard's digital content distribution platform to purchase registrations, download, and manage digital sheet music and other media assets

    The version of the OpenAPI document: 0.2
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.contributor_item import ContributorItem
from openapi_client.models.image_item import ImageItem
from openapi_client.models.instrument_item import InstrumentItem
from openapi_client.models.package_item import PackageItem
from openapi_client.models.price_item import PriceItem
from openapi_client.models.related_good_item import RelatedGoodItem
from openapi_client.models.rendering_item import RenderingItem
from openapi_client.models.usergen_item import UsergenItem
from typing import Optional, Set
from typing_extensions import Self

class AssetItem(BaseModel):
    """
    Digital asset with complete metadata. Represents a digital product available for purchase, including sheet music, recordings, and other media.
    """ # noqa: E501
    asset_id: Optional[StrictInt] = Field(default=None, description="Unique identifier for the asset. This is Hal Leonard's internal identifier for the digital product.")
    format_short_name: Optional[StrictStr] = Field(default=None, description="Short name of the asset format (e.g., PVG for Piano/Vocal/Guitar, SSA for Soprano/Soprano/Alto).")
    format: Optional[StrictStr] = Field(default=None, description="Full name of the asset format (e.g., Piano/Vocal/Guitar, Soprano/Soprano/Alto).")
    page_count: Optional[StrictInt] = Field(default=None, description="The number of pages in the sheet music or document.")
    title: Optional[StrictStr] = Field(default=None, description="Title of the asset (song or composition name).")
    description: Optional[StrictStr] = Field(default=None, description="Detailed description of the asset, including background information, arrangement details, and other relevant content.")
    song_number: Optional[StrictInt] = Field(default=None, description="Hal Leonard's internal song identifier. This is a unique number assigned to each musical composition.")
    public_domain: Optional[StrictBool] = Field(default=None, description="Indicates whether the song represented by this asset exists in the public domain.")
    external_ref: Optional[StrictStr] = Field(default=None, description="Identifier of the company providing the asset. This field identifies the external source or provider of the asset.")
    external_ref_id: Optional[StrictInt] = Field(default=None, description="Numeric identifier of the company providing the asset.")
    voicing: Optional[StrictStr] = Field(default=None, description="Voicing configuration for choral format assets (e.g., SATB for Soprano/Alto/Tenor/Bass, SSA for Soprano/Soprano/Alto).")
    performance_time: Optional[StrictInt] = Field(default=None, description="Performance duration of the asset in seconds.")
    difficulty_level_low: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Lower bound of difficulty level on a scale (typically 1-5 or 1-10).")
    difficulty_level_high: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Upper bound of difficulty level on a scale (typically 1-5 or 1-10).")
    min_qty: Optional[StrictInt] = Field(default=None, description="Minimum allowed purchase quantity, typically enforced on choral format assets to ensure complete sets are purchased.")
    tempo: Optional[StrictInt] = Field(default=None, description="Tempo of the musical piece in beats per minute (BPM).")
    world: Optional[StrictBool] = Field(default=None, description="Indicates if the asset can be sold in all countries (true) or has geographic restrictions (false).")
    retail_price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Hal Leonard's suggested retail price for the asset in the vendor's currency.")
    smd_id: Optional[StrictStr] = Field(default=None, description="SMD (Sheet Music Direct) identifier for the asset.")
    asset_type: Optional[StrictStr] = Field(default=None, description="Type classification of the asset (e.g., FOLIO for folio editions, CHMBK for chord books, PCK for packs).")
    explicit: Optional[StrictBool] = Field(default=None, description="Indicator that denotes whether an asset contains graphic material such as profanity in lyrics.")
    partable: Optional[StrictBool] = Field(default=None, description="Indicator that denotes whether an ensemble's parts may be sold individually.")
    countries: Optional[List[StrictStr]] = Field(default=None, description="List of ISO 3166-1 alpha-2 country codes where the asset is available for sale.")
    instruments: Optional[List[InstrumentItem]] = Field(default=None, description="List of instruments associated with the asset.")
    categories: Optional[List[StrictStr]] = Field(default=None, description="List of categories that classify the asset (e.g., Pop, Rock, Jazz).")
    images: Optional[List[ImageItem]] = Field(default=None, description="List of images associated with the asset (cover art, sample pages, etc.).")
    contributors: Optional[List[ContributorItem]] = Field(default=None, description="List of contributors (composers, arrangers, editors, etc.) associated with the asset.")
    keywords: Optional[List[StrictStr]] = Field(default=None, description="List of keywords associated with the asset for search and discovery.")
    related_goods: Optional[List[RelatedGoodItem]] = Field(default=None, description="List of related goods (physical products, digital bundles, etc.) associated with the asset.")
    renderings: Optional[List[RenderingItem]] = Field(default=None, description="List of available renderings (formats) for the asset (e.g., PDF, Scorch, MusicXML).")
    series: Optional[List[StrictStr]] = Field(default=None, description="List of series that the asset belongs to (e.g., Best Sellers, Top Hits collections).")
    skills: Optional[List[StrictStr]] = Field(default=None, description="List of skill levels or educational classifications associated with the asset.")
    usergens: Optional[List[UsergenItem]] = Field(default=None, description="List of user-generated content or customization options associated with the asset.")
    prices: Optional[List[PriceItem]] = Field(default=None, description="List of pricing options for the asset in different currencies or for different customer segments.")
    packages: Optional[List[PackageItem]] = Field(default=None, description="List of package deals or bundles that include this asset.")
    __properties: ClassVar[List[str]] = ["asset_id", "format_short_name", "format", "page_count", "title", "description", "song_number", "public_domain", "external_ref", "external_ref_id", "voicing", "performance_time", "difficulty_level_low", "difficulty_level_high", "min_qty", "tempo", "world", "retail_price", "smd_id", "asset_type", "explicit", "partable", "countries", "instruments", "categories", "images", "contributors", "keywords", "related_goods", "renderings", "series", "skills", "usergens", "prices", "packages"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AssetItem from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in instruments (list)
        _items = []
        if self.instruments:
            for _item_instruments in self.instruments:
                if _item_instruments:
                    _items.append(_item_instruments.to_dict())
            _dict['instruments'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in images (list)
        _items = []
        if self.images:
            for _item_images in self.images:
                if _item_images:
                    _items.append(_item_images.to_dict())
            _dict['images'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in contributors (list)
        _items = []
        if self.contributors:
            for _item_contributors in self.contributors:
                if _item_contributors:
                    _items.append(_item_contributors.to_dict())
            _dict['contributors'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in related_goods (list)
        _items = []
        if self.related_goods:
            for _item_related_goods in self.related_goods:
                if _item_related_goods:
                    _items.append(_item_related_goods.to_dict())
            _dict['related_goods'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in renderings (list)
        _items = []
        if self.renderings:
            for _item_renderings in self.renderings:
                if _item_renderings:
                    _items.append(_item_renderings.to_dict())
            _dict['renderings'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in usergens (list)
        _items = []
        if self.usergens:
            for _item_usergens in self.usergens:
                if _item_usergens:
                    _items.append(_item_usergens.to_dict())
            _dict['usergens'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in prices (list)
        _items = []
        if self.prices:
            for _item_prices in self.prices:
                if _item_prices:
                    _items.append(_item_prices.to_dict())
            _dict['prices'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in packages (list)
        _items = []
        if self.packages:
            for _item_packages in self.packages:
                if _item_packages:
                    _items.append(_item_packages.to_dict())
            _dict['packages'] = _items
        # set to None if format (nullable) is None
        # and model_fields_set contains the field
        if self.format is None and "format" in self.model_fields_set:
            _dict['format'] = None

        # set to None if page_count (nullable) is None
        # and model_fields_set contains the field
        if self.page_count is None and "page_count" in self.model_fields_set:
            _dict['page_count'] = None

        # set to None if song_number (nullable) is None
        # and model_fields_set contains the field
        if self.song_number is None and "song_number" in self.model_fields_set:
            _dict['song_number'] = None

        # set to None if external_ref (nullable) is None
        # and model_fields_set contains the field
        if self.external_ref is None and "external_ref" in self.model_fields_set:
            _dict['external_ref'] = None

        # set to None if external_ref_id (nullable) is None
        # and model_fields_set contains the field
        if self.external_ref_id is None and "external_ref_id" in self.model_fields_set:
            _dict['external_ref_id'] = None

        # set to None if voicing (nullable) is None
        # and model_fields_set contains the field
        if self.voicing is None and "voicing" in self.model_fields_set:
            _dict['voicing'] = None

        # set to None if performance_time (nullable) is None
        # and model_fields_set contains the field
        if self.performance_time is None and "performance_time" in self.model_fields_set:
            _dict['performance_time'] = None

        # set to None if difficulty_level_low (nullable) is None
        # and model_fields_set contains the field
        if self.difficulty_level_low is None and "difficulty_level_low" in self.model_fields_set:
            _dict['difficulty_level_low'] = None

        # set to None if difficulty_level_high (nullable) is None
        # and model_fields_set contains the field
        if self.difficulty_level_high is None and "difficulty_level_high" in self.model_fields_set:
            _dict['difficulty_level_high'] = None

        # set to None if min_qty (nullable) is None
        # and model_fields_set contains the field
        if self.min_qty is None and "min_qty" in self.model_fields_set:
            _dict['min_qty'] = None

        # set to None if tempo (nullable) is None
        # and model_fields_set contains the field
        if self.tempo is None and "tempo" in self.model_fields_set:
            _dict['tempo'] = None

        # set to None if retail_price (nullable) is None
        # and model_fields_set contains the field
        if self.retail_price is None and "retail_price" in self.model_fields_set:
            _dict['retail_price'] = None

        # set to None if smd_id (nullable) is None
        # and model_fields_set contains the field
        if self.smd_id is None and "smd_id" in self.model_fields_set:
            _dict['smd_id'] = None

        # set to None if countries (nullable) is None
        # and model_fields_set contains the field
        if self.countries is None and "countries" in self.model_fields_set:
            _dict['countries'] = None

        # set to None if instruments (nullable) is None
        # and model_fields_set contains the field
        if self.instruments is None and "instruments" in self.model_fields_set:
            _dict['instruments'] = None

        # set to None if categories (nullable) is None
        # and model_fields_set contains the field
        if self.categories is None and "categories" in self.model_fields_set:
            _dict['categories'] = None

        # set to None if images (nullable) is None
        # and model_fields_set contains the field
        if self.images is None and "images" in self.model_fields_set:
            _dict['images'] = None

        # set to None if contributors (nullable) is None
        # and model_fields_set contains the field
        if self.contributors is None and "contributors" in self.model_fields_set:
            _dict['contributors'] = None

        # set to None if keywords (nullable) is None
        # and model_fields_set contains the field
        if self.keywords is None and "keywords" in self.model_fields_set:
            _dict['keywords'] = None

        # set to None if related_goods (nullable) is None
        # and model_fields_set contains the field
        if self.related_goods is None and "related_goods" in self.model_fields_set:
            _dict['related_goods'] = None

        # set to None if renderings (nullable) is None
        # and model_fields_set contains the field
        if self.renderings is None and "renderings" in self.model_fields_set:
            _dict['renderings'] = None

        # set to None if series (nullable) is None
        # and model_fields_set contains the field
        if self.series is None and "series" in self.model_fields_set:
            _dict['series'] = None

        # set to None if skills (nullable) is None
        # and model_fields_set contains the field
        if self.skills is None and "skills" in self.model_fields_set:
            _dict['skills'] = None

        # set to None if usergens (nullable) is None
        # and model_fields_set contains the field
        if self.usergens is None and "usergens" in self.model_fields_set:
            _dict['usergens'] = None

        # set to None if prices (nullable) is None
        # and model_fields_set contains the field
        if self.prices is None and "prices" in self.model_fields_set:
            _dict['prices'] = None

        # set to None if packages (nullable) is None
        # and model_fields_set contains the field
        if self.packages is None and "packages" in self.model_fields_set:
            _dict['packages'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AssetItem from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "asset_id": obj.get("asset_id"),
            "format_short_name": obj.get("format_short_name"),
            "format": obj.get("format"),
            "page_count": obj.get("page_count"),
            "title": obj.get("title"),
            "description": obj.get("description"),
            "song_number": obj.get("song_number"),
            "public_domain": obj.get("public_domain"),
            "external_ref": obj.get("external_ref"),
            "external_ref_id": obj.get("external_ref_id"),
            "voicing": obj.get("voicing"),
            "performance_time": obj.get("performance_time"),
            "difficulty_level_low": obj.get("difficulty_level_low"),
            "difficulty_level_high": obj.get("difficulty_level_high"),
            "min_qty": obj.get("min_qty"),
            "tempo": obj.get("tempo"),
            "world": obj.get("world"),
            "retail_price": obj.get("retail_price"),
            "smd_id": obj.get("smd_id"),
            "asset_type": obj.get("asset_type"),
            "explicit": obj.get("explicit"),
            "partable": obj.get("partable"),
            "countries": obj.get("countries"),
            "instruments": [InstrumentItem.from_dict(_item) for _item in obj["instruments"]] if obj.get("instruments") is not None else None,
            "categories": obj.get("categories"),
            "images": [ImageItem.from_dict(_item) for _item in obj["images"]] if obj.get("images") is not None else None,
            "contributors": [ContributorItem.from_dict(_item) for _item in obj["contributors"]] if obj.get("contributors") is not None else None,
            "keywords": obj.get("keywords"),
            "related_goods": [RelatedGoodItem.from_dict(_item) for _item in obj["related_goods"]] if obj.get("related_goods") is not None else None,
            "renderings": [RenderingItem.from_dict(_item) for _item in obj["renderings"]] if obj.get("renderings") is not None else None,
            "series": obj.get("series"),
            "skills": obj.get("skills"),
            "usergens": [UsergenItem.from_dict(_item) for _item in obj["usergens"]] if obj.get("usergens") is not None else None,
            "prices": [PriceItem.from_dict(_item) for _item in obj["prices"]] if obj.get("prices") is not None else None,
            "packages": [PackageItem.from_dict(_item) for _item in obj["packages"]] if obj.get("packages") is not None else None
        })
        return _obj


